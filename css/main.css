*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  /* Use inheritance rather than applying style via universal selectors */
  box-sizing: inherit; }

html {
  /* Setting font-size in pixels is a bad practice */
  /* This will hinder with the settings of people who would like to set their own user stylesheet and set their default font-size */
  /* Hence, specify in percentage */
  /* font-size: 10px; */
  /* The child lengths (padding, width, margin, etc) and font-sizes should use rem to refer to this value*/
  font-size: 62.5%; }

/* Everything related to the font should either be applied to the body or html */
body {
  padding: 3rem;
  box-sizing: border-box; }

@keyframes moveInLeft {
  0% {
    transform: translateX(-10rem);
    opacity: 0; }
  80% {
    transform: translateX(1rem); }
  100% {
    transform: translateX(0);
    opacity: 1; } }

@keyframes moveInRight {
  0% {
    transform: translateX(10rem);
    opacity: 0; }
  80% {
    transform: translateX(-1rem); }
  100% {
    transform: translateX(0);
    opacity: 1; } }

@keyframes moveInBtn {
  0% {
    transform: translateY(3rem);
    opacity: 0; }
  100% {
    transform: translateY(0);
    opacity: 1; } }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  font-size: 16px;
  /* 1.7 times bigger than the predefined line-height */
  line-height: 1.7;
  color: #777; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  text-align: center;
  /* 
    Though this hides the 'back' side of the transformed element,
    it also avoids the shaky behavior while animating an element.
    Reasons are yet unknown
  */
  backface-visibility: hidden;
  margin-bottom: 6rem; }
  .heading-primary span {
    display: block; }
  .heading-primary--main {
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out; }
  .heading-primary--sub {
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation-name: moveInRight;
    animation-duration: 1s;
    animation-timing-function: ease-out; }

.btn {
  /* link is a pseudo class which says that the anchor is a link */
  /* visited is a pseudo class which says that the link has been visited */
  /* on clicking, it'll move the button a bit down. Gives a click effect */
  /* Transition is added to initial state */ }
  .btn:link, .btn:visited {
    position: relative;
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    /* inline blocks are treated as text and hence it can be text aligned */
    display: inline-block;
    border-radius: 10rem;
    transition: all 0.2s;
    font-size: 1.6rem; }
  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
    /* scales the copy of the button created with ::after and disappears due to opacity  */ }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    transform: translateY(-1px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }
  .btn--white {
    background-color: #fff;
    color: #777; }
    .btn--white::after {
      background-color: #fff; }
  .btn::after {
    content: "";
    display: inline-block;
    width: 100%;
    height: 100%;
    border-radius: 10rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all 0.4s; }
  .btn--animated {
    animation-name: moveInBtn;
    animation-timing-function: ease-out;
    animation-duration: 0.5s;
    animation-delay: 0.35s;
    /* Adds the style of 0% to the element */
    animation-fill-mode: backwards; }

/* Header CSS Style */
.header {
  /* Instead of setting it 100vh, set it to 95vh so that we just almost stretch to the end */
  height: 95vh;
  position: relative;
  /* First render the gradient and the image */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  background-size: cover;
  /* The top remains the same while the bottom gets cropped */
  background-position: top;
  /* 
  top left corner x y coordinate is 0 0, 
  
  top right corner x coordinate'd be 100% towards right. y didn't change, so 0 
  
  bottom right corner x coordinate'd be 100% towards right, y is 200px towards bottom

  bottom left corner x coordinate'd be 0 back to beginning, y is 100% to the bottom
  */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%); }
  .header__logo-box {
    padding: 4rem 0 0 4rem; }
  .header__logo {
    height: 3.5rem; }
  .header__text-box {
    position: absolute;
    /* This shifts the element to the left and from top by 50% */
    top: 40%;
    left: 50%;
    /* 
  The left and top will make the element start from the specified position 
  due to which the element will not actually be placed in the center. The element positioning will start from the center.

  Hence, we translate (shifted) the element 50% from the current position towards the back in X and Y axis to place it in the center
  */
    transform: translate(-50%, -50%);
    text-align: center; }

.row {
  width: 114rem;
  background-color: #eee;
  margin: 0 auto; }
  .row::after {
    content: "";
    clear: both;
    display: table; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row [class^="col-"] {
    background-color: orangered;
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - (2 * 6rem)) / 3); }
  .row .col-2-of-3 {
    width: calc( 2 * ((100% - (2 * 6rem)) / 3) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - (3 * 6rem)) / 4); }
  .row .col-2-of-4 {
    width: calc( 2 * ((100% - (3 * 6rem)) / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc( 3 * ((100% - (3 * 6rem)) / 4) + (2 * 6rem)); }
